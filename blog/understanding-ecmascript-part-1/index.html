<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Understanding the ECMAScript spec, part 1 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Tutorial on reading the ECMAScript specification" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Understanding the ECMAScript spec, part 1</h1><p class=meta>发布时间：<time datetime="2020-02-03 13:33:37" itemprop=datePublished title="2020-02-03 13:33:37">2020-02-03</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a></header><div itemprop=articleBody><p>In this article, we take a simple function in the spec and try to understand the notation. Let’s go!<h2 id=preface>Preface <a href=#preface class=bookmark>#</a></h2><p>Even if you know JavaScript, reading its language specification, <a href=https://tc39.es/ecma262/ >ECMAScript Language specification, or the ECMAScript spec for short</a>, can be pretty daunting. At least that’s how I felt when I started reading it for the first time.<p>Let’s start with a concrete example and walk through the spec to understand it. The following code demonstrates usage of <code>Object.prototype.hasOwnProperty</code>:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line>o<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span><br><span class=highlight-line>o<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></span></code></pre><p>In the example, <code>o</code> doesn’t have a property called <code>hasOwnProperty</code>, so we walk up the prototype chain and look for it. We find it in <code>o</code>’s prototype, which is <code>Object.prototype</code>.<p>To describe how <code>Object.prototype.hasOwnProperty</code> works, the spec uses pseudocode-like descriptions:<blockquote><p><strong><a href=https://tc39.es/ecma262#sec-object.prototype.hasownproperty><code>Object.prototype.hasOwnProperty(V)</code></a></strong><p>When the <code>hasOwnProperty</code> method is called with argument <code>V</code>, the following steps are taken:<ol><li>Let <code>P</code> be <code>? ToPropertyKey(V)</code>.<li>Let <code>O</code> be <code>? ToObject(this value)</code>.<li>Return <code>? HasOwnProperty(O, P)</code>.</ol></blockquote><p>…and…<blockquote><p><strong><a href=https://tc39.es/ecma262#sec-hasownproperty><code>HasOwnProperty(O, P)</code></a></strong><p>The abstract operation <code>HasOwnProperty</code> is used to determine whether an object has an own property with the specified property key. A Boolean value is returned. The operation is called with arguments <code>O</code> and <code>P</code> where <code>O</code> is the object and <code>P</code> is the property key. This abstract operation performs the following steps:<ol><li>Assert: <code>Type(O)</code> is <code>Object</code>.<li>Assert: <code>IsPropertyKey(P)</code> is <code>true</code>.<li>Let <code>desc</code> be <code>? O.[[GetOwnProperty]](P)</code>.<li>If <code>desc</code> is <code>undefined</code>, return <code>false</code>.<li>Return <code>true</code>.</ol></blockquote><p>But what’s an “abstract operation”? What are the things inside <code>[[ ]]</code>? Why is there a <code>?</code> in front of a function? What do the asserts mean?<p>Let’s find out!<h2 id=language-types-and-specification-types>Language types and specification types <a href=#language-types-and-specification-types class=bookmark>#</a></h2><p>Let’s start with something that looks familiar. The spec uses values such as <code>undefined</code>, <code>true</code>, and <code>false</code>, which we already know from JavaScript. They are all <a href=https://tc39.es/ecma262/#sec-ecmascript-language-types><strong>language values</strong></a>, values of <strong>language types</strong> which the spec also defines.<p>The spec also uses language values internally, for example, an internal data type might contain a field whose possible values are <code>true</code> and <code>false</code>. In contrast, JavaScript engines don’t typically use language values internally. For example, if the JavaScript engine is written in C++, it would typically use the C++ <code>true</code> and <code>false</code> (and not its internal representations of the JavaScript <code>true</code> and <code>false</code>).<p>In addition to language types, the spec also uses <a href=https://tc39.es/ecma262/#sec-ecmascript-specification-types><strong>specification types</strong></a>, which are types that occur only in the spec, but not in the JavaScript language. The JavaScript engine does not need to (but is free to) implement them. In this blog post, we'll get to know the specification type Record (and its subtype Completion Record).<h2 id=abstract-operations>Abstract operations <a href=#abstract-operations class=bookmark>#</a></h2><p><a href=https://tc39.es/ecma262/#sec-abstract-operations><strong>Abstract operations</strong></a> are functions defined in the ECMAScript spec; they are defined for the purpose of writing the spec concisely. A JavaScript engine doesn’t have to implement them as separate functions inside the engine. They cannot be directly called from JavaScript.<h2 id=internal-slots-and-internal-methods>Internal slots and internal methods <a href=#internal-slots-and-internal-methods class=bookmark>#</a></h2><p><a href=https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots><strong>Internal slots</strong> and <strong>internal methods</strong></a> use names enclosed in <code>[[ ]]</code>.<p>Internal slots are data members of a JavaScript object or a specification type. They are used for storing the state of the object. Internal methods are member functions of a JavaScript object.<p>For example, every JavaScript object has an internal slot <code>[[Prototype]]</code> and an internal method <code>[[GetOwnProperty]]</code>.<p>Internal slots and methods are not accessible from JavaScript. For example, you cannot access <code>o.[[Prototype]]</code> or call <code>o.[[GetOwnProperty]]()</code>. A JavaScript engine can implement them for their own internal use, but doesn’t have to.<p>Sometimes internal methods delegate to similarly-named abstract operations, such as in the case of ordinary objects' <code>[[GetOwnProperty]]:</code><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p><code>[[GetOwnProperty]](P)</code></a></strong><p>When the <code>[[GetOwnProperty]]</code> internal method of <code>O</code> is called with property key <code>P</code>, the following steps are taken:<p>Return <code>! OrdinaryGetOwnProperty(O, P)</code>.</blockquote><p>(We’ll find out what the exclamation mark means in the next chapter.)<p><code>OrdinaryGetOwnProperty</code> is not an internal method, since it’s not associated with any object; instead, the object it operates on is passed as a parameter.<p><code>OrdinaryGetOwnProperty</code> is called “ordinary” since it operates on ordinary objects. ECMAScript objects can be either <strong>ordinary</strong> or <strong>exotic</strong>. Ordinary objects must have the default behavior for a set of methods called <strong>essential internal methods</strong>. If an object deviates from the default behavior, it’s exotic.<p>The most well-known exotic object is the <code>Array</code>, since its length property behaves in a non-default way: setting the <code>length</code> property can remove elements from the <code>Array</code>.<p>Essential internal methods are the methods listed <a href=https://tc39.es/ecma262/#table-5>here</a>.<h2 id=completion-records>Completion records <a href=#completion-records class=bookmark>#</a></h2><p>What about the question marks and exclamation marks? To understand them, we need to look into <a href=https://tc39.es/ecma262/#sec-completion-record-specification-type><strong>Completion Records</strong></a>!<p>Completion Record is a specification type (only defined for spec purposes). A JavaScript engine doesn’t have to have a corresponding internal data type.<p>A Completion Record is a “record” — a data type which has a fixed set of named fields. A Completion Record has three fields:<div class=table-wrapper><table><thead><tr><th>Name<th>Description<tbody><tr><td><code>[[Type]]</code><td>One of: <code>normal</code>, <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code>. All other types except <code>normal</code> are <strong>abrupt completions</strong>.<tr><td><code>[[Value]]</code><td>The value that was produced when the completion occurred, for example, the return value of a function or the exception (if one is thrown).<tr><td><code>[[Target]]</code><td>Used for directed control transfers (not relevant for this blog post).</table></div><p>Every abstract operation implicitly returns a Completion Record. Even if it looks like an abstract operation would return a simple type such as Boolean, it’s implicitly wrapped into a Completion Record with the type <code>normal</code> (see <a href=https://tc39.es/ecma262/#sec-implicit-completion-values>Implicit Completion Values</a>).<p>Note 1: The spec is not fully consistent in this regard; there are some helper functions which return bare values and whose return values are used as is, without extracting the value from the Completion Record. This is usually clear from the context.<p>Note 2: The spec editors are looking into making the Completion Record handling more explicit.<p>If an algorithm throws an exception, it means returning a Completion Record with <code>[[Type]]</code> <code>throw</code> whose <code>[[Value]]</code> is the exception object. We’ll ignore the <code>break</code>, <code>continue</code> and <code>return</code> types for now.<p><a href=https://tc39.es/ecma262/#sec-returnifabrupt><code>ReturnIfAbrupt(argument)</code></a> means taking the following steps:<blockquote><ol><li>If <code>argument</code> is abrupt, return <code>argument</code><li>Set <code>argument</code> to <code>argument.[[Value]]</code></ol></blockquote><p>That is, we inspect a Completion Record; if it’s an abrupt completion, we return immediately. Otherwise, we extract the value from the Completion Record.<p><code>ReturnIfAbrupt</code> might look like a function call, but it’s not. It causes the function where <code>ReturnIfAbrupt()</code> occurs to return, not the <code>ReturnIfAbrupt</code> function itself. It behaves more like a macro in C-like languages.<p><code>ReturnIfAbrupt</code> can be used like this:<blockquote><ol><li>Let <code>obj</code> be <code>Foo()</code>. (<code>obj</code> is a Completion Record.)<li><code>ReturnIfAbrupt(obj)</code><li><code>Bar(obj)</code>. (If we’re still here, <code>obj</code> is the value extracted from the Completion Record.)</ol></blockquote><p>And now <a href=https://tc39.es/ecma262/#sec-returnifabrupt-shorthands>the question mark</a> comes into play: <code>? Foo()</code> is equivalent to <code>ReturnIfAbrupt(Foo())</code>.<p>Similarly, <code>Let val be ! Foo()</code> is equivalent to:<blockquote><ol><li>Let <code>val</code> be <code>Foo()</code><li>Assert: <code>val</code> is not an abrupt completion<li>Set <code>val</code> to <code>val.[[Value]]</code>.</ol></blockquote><p>Using this knowledge, we can rewrite <code>Object.prototype.hasOwnProperty</code> like this:<blockquote><p><strong><code>Object.prototype.hasOwnProperty(P)</code></strong><ol><li>Let <code>P</code> be <code>ToPropertyKey(V)</code>.<li>If <code>P</code> is an abrupt completion, return <code>P</code><li>Set <code>P</code> to <code>P.[[Value]]</code><li>Let <code>O</code> be <code>ToObject(this value)</code>.<li>If <code>O</code> is an abrupt completion, return <code>O</code><li>Set <code>O</code> to <code>O.[[Value]]</code><li>Let <code>temp</code> be <code>HasOwnProperty(O, P)</code>.<li>If <code>temp</code> is an abrupt completion, return <code>temp</code><li>Let <code>temp</code> be <code>temp.[[Value]]</code><li>Return <code>NormalCompletion(temp)</code></ol></blockquote><p>…and we can rewrite <code>HasOwnProperty</code> like this:<blockquote><p><strong><code>HasOwnProperty(O, P)</code></strong><ol><li>Assert: <code>Type(O)</code> is <code>Object</code>.<li>Assert: <code>IsPropertyKey(P)</code> is <code>true</code>.<li>Let <code>desc</code> be <code>O.[[GetOwnProperty]](P)</code>.<li>If <code>desc</code> is an abrupt completion, return <code>desc</code><li>Set <code>desc</code> to <code>desc.[[Value]]</code><li>If <code>desc</code> is <code>undefined</code>, return <code>NormalCompletion(false)</code>.<li>Return <code>NormalCompletion(true)</code>.</ol></blockquote><p>We can also rewrite the <code>[[GetOwnProperty]]</code> internal method without the exclamation mark:<blockquote><p><strong><code>O.[[GetOwnProperty]]</code></strong><ol><li>Let <code>temp</code> be <code>OrdinaryGetOwnProperty(O, P)</code><li>Assert: <code>temp</code> is not an abrupt completion<li>Let <code>temp</code> be <code>temp.[[Value]]</code><li>Return <code>NormalCompletion(temp)</code></ol></blockquote><p>Here we assume that <code>temp</code> is a brand new temporary variable which doesn’t collide with anything else.<p>We’ve also used the knowledge that when a return statement returns something else than a Completion Record, it’s implicitly wrapped inside a <code>NormalCompletion</code>.<h3 id=side-track%3A-return-%3F-foo()>Side track: <code>Return ? Foo()</code> <a href=#side-track%3A-return-%3F-foo() class=bookmark>#</a></h3><p>The spec uses the notation <code>Return ? Foo()</code> — why the question mark?<p><code>Return ? Foo()</code> expands to:<blockquote><ol><li>Let <code>temp</code> be <code>Foo()</code><li>If <code>temp</code> is an abrupt completion, return <code>temp</code><li>Set <code>temp</code> to <code>temp.[[Value]]</code><li>Return <code>NormalCompletion(temp)</code></ol></blockquote><p>Which is the same as <code>Return Foo()</code>; it behaves the same way for both abrupt and normal completions.<h2 id=asserts>Asserts <a href=#asserts class=bookmark>#</a></h2><p>Asserts in the spec assert invariant conditions of the algorithms. They are added for clarity, but don't add any requirements to the implementation — the implementation doesn’t need to check them.<h2 id=moving-on>Moving on <a href=#moving-on class=bookmark>#</a></h2><p>We have built the understanding needed for reading the spec for simple methods like <code>Object.prototype.hasOwnProperty</code> and abstract operations like <code>HasOwnProperty</code>. They still delegate to other abstract operations, but based on this blog post we should be able to figure out what they do. We’ll encounter Property Descriptors, which is just another specification type.<figure><img alt="Function call graph starting from Object.prototype.hasOwnProperty" height=306 src=/_img/understanding-ecmascript-part-1/call-graph.svg width=1082></figure><h2 id=useful-links>Useful links <a href=#useful-links class=bookmark>#</a></h2><p><a href=https://timothygu.me/es-howto/ >How to Read the ECMAScript Specification</a>: a tutorial which covers much of the material covered in this post, from a slightly different angle.</div><footer><div><img alt="" height=96 src=/_img/avatars/marja-holtta.jpg width=96 loading=lazy srcset="/_img/avatars/marja-holtta@2x.jpg 2x"><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, speculative specification spectator.</div><a href=https://twitter.com/v8js/status/1224363301146189824 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/understanding-ecmascript-part-1>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/understanding-ecmascript-part-1.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>